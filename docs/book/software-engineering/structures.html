
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Algorithms &amp; Data Structures &#8212; Data Science Hand.. 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/style.css" />
    <link rel="stylesheet" href="../../_static/css/style.css" type="text/css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.12.4.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.4.1/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          Handbook</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Section <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Algorithms &amp; Data Structures</a><ul>
<li><a class="reference internal" href="#time-complexity">Time Complexity</a></li>
<li><a class="reference internal" href="#notation-examples">Notation Examples</a></li>
<li><a class="reference internal" href="#sort-algorithms">Sort Algorithms</a><ul>
<li><a class="reference internal" href="#quicksort">Quicksort</a></li>
<li><a class="reference internal" href="#merge-sort">Merge Sort</a></li>
</ul>
</li>
<li><a class="reference internal" href="#array">Array</a></li>
<li><a class="reference internal" href="#deque-python">Deque (Python)</a></li>
<li><a class="reference internal" href="#linked-list">Linked List</a></li>
<li><a class="reference internal" href="#stacks">Stacks</a></li>
<li><a class="reference internal" href="#queues">Queues</a></li>
<li><a class="reference internal" href="#hash-map">Hash Map</a></li>
<li><a class="reference internal" href="#recursion">Recursion</a></li>
<li><a class="reference internal" href="#binary-trees">Binary Trees</a></li>
<li><a class="reference internal" href="#binary-search-trees">Binary Search Trees</a><ul>
<li><a class="reference internal" href="#traversals">Traversals</a></li>
</ul>
</li>
<li><a class="reference internal" href="#depth-first-search-trees">Depth First Search Trees</a></li>
<li><a class="reference internal" href="#breadth-first-search">Breadth First Search</a></li>
<li><a class="reference internal" href="#dfs-vs-bfs">DFS vs BFS</a></li>
<li><a class="reference internal" href="#heaps">Heaps</a></li>
<li><a class="reference internal" href="#backtracking">Backtracking</a></li>
<li><a class="reference internal" href="#trie-data-structure">Trie Data Structure</a></li>
<li><a class="reference internal" href="#greedy-algorithm">Greedy Algorithm</a></li>
<li><a class="reference internal" href="#knuth-morris-pratt">Knuth-Morris-Pratt</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="algorithms-data-structures">
<h1>Algorithms &amp; Data Structures<a class="headerlink" href="#algorithms-data-structures" title="Permalink to this headline"></a></h1>
<hr class="docutils" />
<div class="section" id="time-complexity">
<h2>Time Complexity<a class="headerlink" href="#time-complexity" title="Permalink to this headline"></a></h2>
<p><strong><span class="label label-success">Cheat Sheet</span></strong></p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.geeksforgeeks.org/complexity-cheat-sheet-for-python-operations/">Link</a></p></li>
</ul>
<p><img alt="image" src="../../_images/time_complexity1.png" /></p>
<p><img alt="image" src="../../_images/time_complexity2.png" /></p>
</div>
<div class="section" id="notation-examples">
<h2>Notation Examples<a class="headerlink" href="#notation-examples" title="Permalink to this headline"></a></h2>
<p><strong>O(1):</strong></p>
<ul class="simple">
<li><p>Linear operation</p></li>
<li><p>Hashmap look-up</p></li>
<li><p>Finding min/max values in a Heap</p></li>
</ul>
<p><strong>O(n):</strong></p>
<ul class="simple">
<li><p>Iterative loop</p></li>
<li><p>Adding/Removing elements from a list</p></li>
<li><p>Binary Trees</p></li>
</ul>
<p><strong>O(n^2):</strong></p>
<ul class="simple">
<li><p>Loop inside of a loop</p></li>
<li><p>Quick Sort (worst case); depends on position of the pivot.</p></li>
</ul>
<p><strong>O(log n):</strong></p>
<ul class="simple">
<li><p>Binary Search: input size is divided in half for each loop</p></li>
<li><p>Insert/Delete/Search for Binary Trees or Heaps</p></li>
</ul>
<p><strong>O(nlogn):</strong></p>
<ul class="simple">
<li><p>Sort input array</p></li>
<li><p>Heap sort</p></li>
<li><p>Quick Sort (best case)</p></li>
<li><p>Merge Sort</p></li>
</ul>
</div>
<hr class="docutils" />
<div class="section" id="sort-algorithms">
<h2>Sort Algorithms<a class="headerlink" href="#sort-algorithms" title="Permalink to this headline"></a></h2>
<div class="section" id="quicksort">
<h3>Quicksort<a class="headerlink" href="#quicksort" title="Permalink to this headline"></a></h3>
<p><strong><span class="label label-success">Steps</span></strong></p>
<ul class="simple">
<li><p>Iterate over each element in the list and check if it’s smaller than the pivot.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">pivot</span></code>: splits the list in half and is often taken as the median of
initial, mean, and ending value of the list.</p></li>
</ul>
</li>
<li><p>Next, move the pivot value to index_0.</p></li>
<li><p>Now we will have two pointers, <code class="docutils literal notranslate"><span class="pre">i</span></code> at index_1 and <code class="docutils literal notranslate"><span class="pre">j</span></code> at index_2.</p>
<ul>
<li><p>We will loop over the list and check if <code class="docutils literal notranslate"><span class="pre">j</span></code> is less than the <code class="docutils literal notranslate"><span class="pre">pivot</span></code>,</p></li>
<li><p>If so, swap the values of <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> and advance the pointers.</p>
<ul>
<li><p>In this case, everything less than the index of <code class="docutils literal notranslate"><span class="pre">i</span></code> is less than the pivot
value and everything to the right of i is greater than the pivot value. If <code class="docutils literal notranslate"><span class="pre">j</span></code>
is greater than the pivot value, keep incrementing the index of <code class="docutils literal notranslate"><span class="pre">j</span></code> to to
the end of list.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Next swap the pivot value with value in index <code class="docutils literal notranslate"><span class="pre">i</span></code>.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">smaller</span></code> == left partition</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">larger</span></code> == right partition</p></li>
</ul>
</li>
<li><p>This is a recursive function and we can now call the quick sort algorithm on
the left hand and right hand side of the list.</p></li>
</ul>
</div>
<div class="section" id="merge-sort">
<h3>Merge Sort<a class="headerlink" href="#merge-sort" title="Permalink to this headline"></a></h3>
<ul class="simple">
<li><p>Merge sort is a divide and conquer algorithm</p></li>
<li><p>Recursive as the method calls itself</p></li>
<li><p>MergeSort function repeatedly divides the array into two halves until we
reach a stage where we try to perform MergeSort on a subarray of size.</p></li>
<li><p>Next, the merge function picks up the sorted sub-arrays and merges them to
gradually sort the entire array.</p></li>
<li><p>Very efficient for large datasets.</p></li>
<li><p>Reference: https://www.programiz.com/dsa/merge-sort</p></li>
</ul>
<p><img alt="image" src="../../_images/merge_sort.png" /></p>
</div>
</div>
<hr class="docutils" />
<div class="section" id="array">
<h2>Array<a class="headerlink" href="#array" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Structure of fixed-size, which can hold items of the same data type. - It can
be an array of  integers, an array of floating-point numbers, an array of
strings or even an array of arrays (such as 2-dimensional arrays).</p></li>
<li><p>Arrays are indexed, meaning that random access is possible.</p></li>
<li><p><strong>Traverse</strong>: Go through the elements and print them.</p></li>
<li><p><strong>Search</strong>: Search for an element in the array. You can search the element by
its value or its index</p></li>
<li><p><strong>Update</strong>: Update the value of an existing element at a given index</p></li>
</ul>
<p><img alt="image" src="../../_images/array.png" /></p>
</div>
<div class="section" id="deque-python">
<h2>Deque (Python)<a class="headerlink" href="#deque-python" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Deque (<code class="docutils literal notranslate"><span class="pre">Doubly</span> <span class="pre">Ended</span> <span class="pre">Queue</span></code>) in Python is implemented using the module “collections“.</p></li>
<li><p>Deque is preferred over list in the cases where we need quicker append and
pop operations from both the ends of container, as deque provides an O(1)
time complexity for append and pop operations as compared to list which
provides O(n) time complexity.</p></li>
</ul>
</div>
<div class="section" id="linked-list">
<h2>Linked List<a class="headerlink" href="#linked-list" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Sequential structure that consists of a sequence of items in linear order
which are linked to each  other. Hence, you have to access data sequentially
and random access is not possible.</p></li>
<li><p>Linked lists provide a simple and flexible representation of dynamic sets</p></li>
<li><p>Elements in a linked list are known as nodes.</p>
<ul>
<li><p>Each node contains a key and a pointer to its successor node, known as next.</p></li>
<li><p>The attribute named head points to the first element of the linked list.</p></li>
<li><p>The last element of the linked list is known as the tail.</p></li>
</ul>
</li>
</ul>
<p><img alt="image" src="../../_images/linked_list.png" /></p>
</div>
<div class="section" id="stacks">
<h2>Stacks<a class="headerlink" href="#stacks" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Linear data structure that stores items in a <code class="docutils literal notranslate"><span class="pre">Last-In/First-Out</span></code> or <code class="docutils literal notranslate"><span class="pre">First-In/Last-Out</span></code>.</p></li>
<li><p>A new element is added at one end and an element is removed from that end only.</p></li>
<li><p>The insert and delete operations are often called push and pop.</p></li>
<li><p><strong>Push</strong>: Insert an element on to the top of the stack.</p></li>
<li><p><strong>Pop</strong>: Delete the topmost element and return it.</p></li>
</ul>
<p><img alt="image" src="../../_images/stacks.png" /></p>
</div>
<div class="section" id="queues">
<h2>Queues<a class="headerlink" href="#queues" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Linear data structure that stores items in First In First Out (FIFO).</p></li>
<li><p>With a queue the least recently added item is removed first.
<strong>Enqueue</strong>: Insert an element to the end of the queue.
<strong>Dequeue</strong>: Delete the element from the beginning of the queue.</p></li>
</ul>
<p><img alt="image" src="../../_images/queues.png" /></p>
</div>
<div class="section" id="hash-map">
<h2>Hash Map<a class="headerlink" href="#hash-map" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>A special function named as the hash function (h) is used to overcome the
aforementioned problem in direct addressing.</p></li>
<li><p>In direct accessing, a value with key k is stored in the slot k. Using the
hash function, we calculate the index of the table (slot) to which each
value goes. The value calculated using the hash function for a given key is
called the hash value which indicates the index of the table to which the
value is mapped.</p>
<ul>
<li><p><strong>h</strong>: Hash function</p></li>
<li><p><strong>k</strong>: Key of which the hash value should be determined</p></li>
<li><p><strong>m</strong>: Size of the hash table (number of slots available). A prime value
that is not close to an exact power of 2 is a good choice for m.</p></li>
</ul>
</li>
</ul>
<p><img alt="image" src="../../_images/hash_map.png" /></p>
</div>
<div class="section" id="recursion">
<h2>Recursion<a class="headerlink" href="#recursion" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Recursion is a method of solving problems that involves breaking a problem
down into smaller and smaller subproblems until you get to a small enough
problem that it can be solved trivially.</p></li>
<li><p>Usually recursion involves a function calling itself.</p></li>
</ul>
<p><img alt="image" src="../../_images/recursion.png" />
<a class="reference external" href="https://www.youtube.com/watch?v=wMNrSM5RFMc">Reference - python recursion explained</a></p>
<p><strong><span class="label label-info">Notes</span></strong></p>
<ul class="simple">
<li><p>A recursive algorithm must have a base case.</p></li>
<li><p>A recursive algorithm must change its state and move toward the base case.</p></li>
<li><p>A recursive algorithm must call itself, recursively.</p></li>
</ul>
<p><strong>Recursive function in Python</strong></p>
<ul class="simple">
<li><p>When a function is called in Python, a stack frame is allocated to handle the
local variables of the function.</p></li>
<li><p>When the function returns, the return value is left on top of the stack for
the calling function to access.</p></li>
<li><p>Even though we are calling the same function over and over, each call creates
a new scope for the variables that are local to the function.</p></li>
</ul>
</div>
<div class="section" id="binary-trees">
<h2>Binary Trees<a class="headerlink" href="#binary-trees" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>A tree is a hierarchical structure where data is organized hierarchically and
are linked together. This structure is different from a linked list whereas,
in a linked list, items are linked in a linear order.</p></li>
<li><p>Every node in a binary search tree comprises the following attributes.</p>
<ul>
<li><p><strong>key</strong>: The value stored in the node.</p></li>
<li><p><strong>left</strong>: The pointer to the left child.</p></li>
<li><p><strong>right</strong>: The pointer to the right child.</p></li>
<li><p><strong>p</strong>: The pointer to the parent node.</p></li>
</ul>
</li>
</ul>
<p><img alt="image" src="../../_images/binary_tree.png" /></p>
</div>
<div class="section" id="binary-search-trees">
<h2>Binary Search Trees<a class="headerlink" href="#binary-search-trees" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>A binary search tree (BST), as the name suggests, is a binary tree where data
is organized in a hierarchical structure. This data structure stores values
in sorted order.</p></li>
<li><p>Nodes are arranged in a BST with the following properties</p>
<ul>
<li><p>The left subtree of a particular node will always contain nodes with keys
less than that node’s key.</p></li>
<li><p>The right subtree of a particular node will always contain nodes with keys
greater than that node’s key.</p></li>
<li><p>The left and the right subtree of a particular node will also, in turn, be
binary search trees.</p></li>
</ul>
</li>
<li><p><a class="reference external" href="https://www.educative.io/edpresso/what-is-a-binary-search-tree">Reference</a></p></li>
</ul>
<div class="section" id="traversals">
<h3>Traversals<a class="headerlink" href="#traversals" title="Permalink to this headline"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>         <span class="n">_10_</span>
        <span class="o">/</span>     \
       <span class="mi">7</span>       <span class="mi">11</span>
     <span class="o">/</span>  \        \
    <span class="mi">6</span>    <span class="mi">8</span>       <span class="mi">20</span>
   <span class="o">/</span>      \     <span class="o">/</span>   \
   <span class="mi">1</span>      <span class="mi">9</span>    <span class="mi">14</span>   <span class="mi">22</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Pre-order:</strong></p>
<ul>
<li><p>traversal will visit nodes in <code class="docutils literal notranslate"><span class="pre">Parent</span></code>-<code class="docutils literal notranslate"><span class="pre">LeftChild</span></code>-<code class="docutils literal notranslate"><span class="pre">RightChild</span></code> order.</p></li>
<li><p>Example: [10, 7, 6, 1, 8, 9, 11, 20, 14, 22] –&gt; Root -&gt; Left -&gt; Right</p></li>
</ul>
</li>
<li><p><strong>In-order:</strong></p>
<ul>
<li><p>traversal will visit nodes in <code class="docutils literal notranslate"><span class="pre">LeftChild</span></code>-<code class="docutils literal notranslate"><span class="pre">Parent</span></code>-<code class="docutils literal notranslate"><span class="pre">RightChild</span></code> order.</p></li>
<li><p>In this way, the tree is traversed in an ascending order of keys.</p></li>
<li><p>Example:[1, 6, 7, 8, 9, 10, 11, 14, 20, 22] –&gt; Left -&gt; Root -&gt; Right</p></li>
</ul>
</li>
<li><p><strong>Post-order:</strong></p>
<ul>
<li><p>Traversal will visit nodes in <code class="docutils literal notranslate"><span class="pre">LeftChild</span></code>-<code class="docutils literal notranslate"><span class="pre">RightChild</span></code>-<code class="docutils literal notranslate"><span class="pre">Parent</span></code> order</p></li>
<li><p>[1, 6, 9, 8, 7, 14, 22, 20, 11, 10] –&gt; Left -&gt; Right -&gt; Root</p></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="depth-first-search-trees">
<h2>Depth First Search Trees<a class="headerlink" href="#depth-first-search-trees" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Recursive algorithm to traverse a tree in a depth first manner.</p></li>
<li><p>Depth-first search is an algorithm for traversing or searching tree or graph
data structures.</p></li>
<li><p>The algorithm starts at the root node (selecting some arbitrary node as the
root node in the case of  a graph) and explores as far as possible along each
branch before backtracking.</p></li>
</ul>
<p><strong><span class="label label-info">Stpes</span></strong></p>
<ul class="simple">
<li><p>Start from the root or any arbitrary node and mark the node and move to the
adjacent unmarked node.
continue this loop until there is no unmarked adjacent node.</p></li>
<li><p>Then backtrack and check for other unmarked nodes and traverse them.</p></li>
<li><p>Finally, print the nodes in the path.</p></li>
</ul>
<p><strong>Algorithm</strong>:</p>
<ul class="simple">
<li><p>Create a recursive function that takes the index of the node and a visited array.</p></li>
<li><p>Mark the current node as visited and print the node.</p></li>
<li><p>Traverse all the adjacent and unmarked nodes and call the recursive function
with the index of the adjacent node.</p></li>
</ul>
<p><strong>Example</strong></p>
<p><img alt="image" src="../../_images/dfs1.png" />
<img alt="image" src="../../_images/dfs2.png" /></p>
</div>
<div class="section" id="breadth-first-search">
<h2>Breadth First Search<a class="headerlink" href="#breadth-first-search" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>BFS is an iterative algorithm for traversing or searching tree or graph data
structures.</p></li>
<li><p>The data structure commonly used for memory allocation is a queue.</p></li>
<li><p>BFS algorithm starts at the root node and explores all the adjacent nodes
before moving to the next level.</p></li>
<li><p>Example of BFS <a class="reference external" href="https://www.youtube.com/watch?v=pV2kpPD66nE&amp;t=602s">here</a>.</p></li>
</ul>
</div>
<div class="section" id="dfs-vs-bfs">
<h2>DFS vs BFS<a class="headerlink" href="#dfs-vs-bfs" title="Permalink to this headline"></a></h2>
<p><img alt="image" src="../../_images/dfs3.png" /></p>
</div>
<div class="section" id="heaps">
<h2>Heaps<a class="headerlink" href="#heaps" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>A special case of a binary tree where the parent nodes are compared to their
children with their values and are arranged accordingly.
Only the root is deleted when performing a delete operation.</p></li>
</ul>
<p><strong>Min Heap</strong></p>
<ul class="simple">
<li><p>The key of the parent is less than or equal to those of its children. This is
called the min-heap property. The root will contain the minimum value of the
heap.</p></li>
</ul>
<p><strong>Max Heap</strong></p>
<ul class="simple">
<li><p>The key of the parent is greater than or equal to those of its children. This
is called the max-heap property. The root will contain the maximum value of
the heap.</p></li>
</ul>
<p><img alt="image" src="../../_images/max_heap.png" /></p>
</div>
<div class="section" id="backtracking">
<h2>Backtracking<a class="headerlink" href="#backtracking" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Common algorithm used when you want to “find all possible solution”</p></li>
<li><p>Backtracking is an algorithmic-technique for solving problems recursively by
trying to build a solution incrementally, one piece at a time, removing
those solutions that fail to satisfy the constraints of the problem at any
tpoint of time</p></li>
</ul>
<p><strong>Main points of Backtracking</strong>
1.) Choice: you a make a choice at each step,
2.) Constrains on the choices.
3.) Converge on goals.</p>
<p><img alt="image" src="../../_images/backtracking1.png" /></p>
<p><img alt="image" src="../../_images/backtracking2.png" /></p>
</div>
<div class="section" id="trie-data-structure">
<h2>Trie Data Structure<a class="headerlink" href="#trie-data-structure" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Common task for using this type of data structure is used for is for
<code class="docutils literal notranslate"><span class="pre">Autocomplete</span></code> tasks. See steps below:</p></li>
</ul>
<p><img alt="image" src="../../_images/trie.png" /></p>
<p><strong><span class="label label-success">Steps</span></strong></p>
<ul class="simple">
<li><p>Search for the given query using the standard Trie search algorithm.</p></li>
<li><p>If the query prefix itself is not present, return -1 to indicate the same.</p></li>
<li><p>If the query is present and is the end of a word in Trie, print the query.
This can quickly be checked by - seeing if the last matching node has
isEndWord flag set. We use this flag in Trie to mark the end of word nodes
for the purpose of searching.</p></li>
<li><p>If the last matching node of the query has no children, return.</p></li>
<li><p>Else recursively print all nodes under a subtree of the last matching node.</p></li>
</ul>
<p>[Reference](Reference: https://www.geeksforgeeks.org/auto-complete-feature-using-trie/)</p>
<p><strong>References</strong>
<a class="reference external" href="https://www.youtube.com/channel/UCZCFT11CWBi3MHNlGf019nw">Abdul Bari YouTube
Channel</a>
<a class="reference external" href="https://www.youtube.com/c/NeetCode">NeetCode YouTube Channel</a></p>
</div>
<div class="section" id="greedy-algorithm">
<h2>Greedy Algorithm<a class="headerlink" href="#greedy-algorithm" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>A greedy algorithm is an algorithmic strategy that makes the best optimal choice at each small stage with the goal of this eventually leading to a globally optimum solution.</p></li>
<li><p>This means that the algorithm picks the best solution at the moment without regard for consequences. It picks the best immediate output, but does not consider the big picture, hence it is considered greedy.</p></li>
<li><p><a class="reference external" href="https://www.geeksforgeeks.org/greedy-algorithms/">Reference</a></p></li>
<li><p><a class="reference external" href="https://www.techopedia.com/definition/16931/greedy-algorithm">Reference</a></p></li>
</ul>
</div>
<div class="section" id="knuth-morris-pratt">
<h2>Knuth-Morris-Pratt<a class="headerlink" href="#knuth-morris-pratt" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>A string matching algorithm that uses the longest prefix of the pattern that is also a suffix of the pattern.</p></li>
</ul>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../../_sources/book/software-engineering/structures.md.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2021, Trace Smith, Damon Resnick.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.2.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>